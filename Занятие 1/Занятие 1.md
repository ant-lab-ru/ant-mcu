
## Проверяем установку необходимых программ

### Важные общие принципы
#### Path

Компьютерная программа - это набор инструкций и данных, запускаемый через исполняемый файл с расширением .exe на Windows и без расширения на Linux/MacOS. Установить программу - значит скачать исполняемый файл и набор дополнительных файлов вместе с ним, распаковать их, преобразовать и разместить их в нужном месте файловой системы компьютера. Все эти действия автоматически делает установщик программы, именно его вы обычно скачиваете и запускаете. Для офисного ПО, игр и прочих бытовых задач достаточно скачать и запустить установщик. Однако, для разработки необходимо обеспечить возможность одним программам находить другие, а так же запускать программы из терминала. Чтобы это было возможно, в настройках системы необходимо отметить существование свежеустановленной программы. Для этого используются так называемые переменные среды, а именно переменная PATH. **Для того, чтобы программа была доступна для запуска из терминала, необходимо в PATH добавить путь к ее исполняемому файлу**. На linux и macos это автоматически делает пакетный менеджер, на windows либо в установщике может быть такая галочка, которую нужно поставить, либо надо добавить переменную самостоятельно.
Типовая проблема на WIndows, что программа установлна, но в терминале она не доступна, заключается именно в том, что данная программа не добавлена в PATH.
#### Командная строка

Для выполнения большинства действий мы будем использовать командную строку (терминал, консоль).
- Linux
	командна строка стандартная и запускается сочетанием клавишь **Ctrl+Alt+T** либо как приложение Terminal.
- MacOS
	можно использовать стандартный Tetminal.app или iTerm.app, лишенный некоторых недостатков стандартного терминала.
- Windows
	в windows есть два приложения реализующие терминал - это cmd и powershell. Оба имеют неудобства, однако ==в данном курсе следует использовать powershell==, т.к. он имеет unix сокращения базовых операций, сохранение команд между запусками и поиск. Если терминал пишет, что некоторая команда не существует, проверьте, действительно ли вы работает в powershell.

#### Пакетный менеджер

Здесь краткая информация о том, как устанавливать программы на компьютер.
- Linux
	на линукс есть встроенный пакетный менеджер apt, все установки делаются через него, дополнительные действия не нужны.
- MacOS
	на MacOS необходимо установить (если он до сих пор не установлен) пакетный менеджер homebrew и использовать его командой brew.
- Windows
	хоть на windows и существуют пакетные менеджеры, они имеют ряд проблем, поэтому установки всех программ прозводятся путем скачивания и запуска официального установщика нужной программы.

### Задание

Открываем терминал и последовательно проверяем установку всех нужных программ.
Если программа не установлена - устанавливаем. Если программа установлена, но не доступна через терминал - разбираемся с PATH.

#### 1. Система контроля версий git

- выполнить в терминале:

``` bash
git --version
```
 
- в ответ должна отобразиться версия, например `git version 2.52.0`;
- если версии нет, нужно [[Установить git]];

#### 2. Система автоматизации сборки программного обеспечения cmake

- выполнить в терминале:

``` bash
cmake --version
```

- в ответ должна отобразиться версия, например `cmake version 4.2.1`;
- если версии нет, нужно [[Установить cmake]];

#### 3. Система исполнения сценариев make

- выполнить в терминале:

``` bash
make --version
```

- в ответ должна отобразиться версия, например `GNU Make 3.81`;
- если версии нет, нужно [[Установить make]].

#### 4. Компилятор arm-none-eabi-gcc
 
- выполнить в терминале:

``` bash
arm-none-eabi-gcc --version
```

- в ответ должна отобразиться версия, например arm-none-eabi-gcc (Arm GNU Toolchain 15.2.Rel1 (Build arm-15.86)) 15.2.1 20251203
- если версии нет, нужно [[Установить arm-none-eabi-gcc]]

#### 5. Утилита для преобразования прошивок RP2040 picotool

 - выполнить в терминале

``` bash
picotool version
```

- в ответ должна отобразиться версия, например `picotool v2.2.0-a4`;
- если версии нет, нужно [[Установить picotool]];

#### 6. Редактор кода VSCode

- выполнить в терминале

``` bash
code --version
```

- в ответ должна отобразиться версия, например `1.108.2`;
- если версии нет, нужно [[Установить VSCode]].
## Скачиваем SDK, создаем свой репозиторий, организуем структуру папок

- Создаем папку для разработки прошивки:

```
C:\Repositories\ant-mcu
# Не обязательно работать именно в корне, рекомендуется организовать
# структуру папок, например ~/projects/
```

``` bash
# Для MacOS и Linux переходим в директорию пользователя
cd ~/Repositories/pico

# Для Windows переходим на диск С: (либо любой другой), чтобы
# избежать кирилических символов в пути
cd C:/Repositories/pico
```
- Создаем репозиторий на своем github с названием `mcu`;
- Настраиваем и проверяем ssh соединение;
- Клонируем свой репозиторий:
``` bash
# Клонируем в папку pico свой свежесозданный реозиторий mcu
# (username надо заменить на свое имя)
git clone git@github.com:username/mcu.git
```
- Клонируем набор инструментов и библиотек pico-sdk для разработки прошивок под микроконтроллеры Raspberry:
``` bash
# Клонируем в папку pico репозиторий Pico SDK
git clone -b master https://github.com/raspberrypi/pico-sdk.git
# Переходим в pico-sdk, чтобы скачать его сабмодули
cd pico-sdk
git submodule update --init
```

В результате вышеописанных действий на компьютере, в папке pico, должна появиться содержащая весь SDK папка pico-sdk. В ней мы ничего не меняем, это набор инструментов от производителя pico для создания прошивок под их микроконтроллеры. Также, должна появится пустая папка ```mcu```, в которой мы будем создавать наши собственные программы:
```
pico
|-- mcu
|-- pico-sdk
```


> [!ATTENTION] Внимание!
> 
> Обязательным шагом после клонирования pico-sdk является установка переменной среды PICO_SDK_PATH на путь к папке pico-sdk (в примере это `C:/Repositories/pico/pico-sdk/`). [[Как добавить системную переменную]]. После добавления переменной нужно перезагрузить терминал, чтобы переменная стала доступна!

## Создаем первый проект

1. Создаем папку с первой прошивкой, ее задача будет помигать светодиодом, поэтому называем ее `01-blink`. Последняя команда откроет эту папку в VSCode;

``` bash
cd mcu
mkdir 01-blink
cd 01-blink
code .
```

> [!INFO] Обратите внимание
>  Все эти команды выше эквивалентны тем, что мы привыкли делать кликая мышкой: открыть папку, создать папку, открыть приложение. Однако, в отличии от кликов мышкой, работу с компьютером через терминал легко автоматизировать.

2. Копируем файл `pico_sdk_import.cmake` из `pico/pico-sdk/external/pico_sdk_import.cmake`;

> [!INFO] Справка
>  `pico_sdk_import.cmake` - это вспомогательный CMake скрипт, который упрощает подключение Pico SDK (комплекта для разработки под Raspberry Pi Pico) к вашему проекту на C/C++.

3. копируем файл `pico/pico-sdk/src/rp2_common/pico_crt0/rp2040/memmap_default.ld` в папку проекта и меняем его имя на `memmap_rp2040.ld`;

> [!INFO] Справка
>  `memmap_rp2040.ld` - это [[скрипт компоновщика]] (linker script), отвечает сборку фрагментов скомпилированного кода в единое целое и за разметку FALSH и RAM памяти микроконтоллера

4. создаем файл с исходным кодом `main.c`. Пишем в этот файл минимально рабочий пример кода, который мигает светодиодом

``` c
// подключаем библиотеки из pico SDK
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// задаем константу с номером вывода, к которому подключен светодиод
// номер можно узнать и проверить в документации к плате
const uint LED_PIN = 25;

int main()
{
	// Инициализация GPIO вывода
	gpio_init(LED_PIN);
	gpio_set_dir(LED_PIN, GPIO_OUT);

	// Бесконечный цикл, чтобы светодиод мигал все время
	while (1)
	{
		gpio_put(LED_PIN, 0);
		sleep_ms(250);
		gpio_put(LED_PIN, 1);
		sleep_ms(1000);
	}
}
```

- Создаем файл со скриптом сборки нашего проекта `CMakeLists.txt`. Пишем в этот файл скрипт для сборки прошивки под RP2040

``` cmake

# Требуем минимальную версию cmake - типовая строчка для любого CMakeLists.txt
cmake_minimum_required(VERSION 3.15)

# Задаем параметр с используемой платой и микроконтроллером для Pico SDK - специфика сборки под Pico
set(PICO_BOARD pico)
set(PICO_PLATFORM rp2040)

# Добавляем файл, автоматически подтягивающий Pico SDK в наш проект - специфика сборки под Pico
include(pico_sdk_import.cmake)

# Создаем проект с именем 01_blink - типовая строчка для любого CMakeLists.txt
project(01_blink)

# Вызываем функцию инициализации Pico SDK - специфика сборки под Pico
pico_sdk_init()

# Добавляем в проект файлы с исходным кодом - типовая строчка для любого CMakeLists.txt
add_executable(01_blink
	${CMAKE_CURRENT_SOURCE_DIR}/main.c
)

# Указываем на какие библиотеки ссылается наш код - типовая строчка для любого CMakeLists.txt
target_link_libraries(01_blink
	pico_stdlib
)

# Указываем файл, в котором находится линкер скрипт - специфика сборки под МК
pico_set_linker_script(01_blink ${CMAKE_CURRENT_SOURCE_DIR}/memmap_rp2040.ld)

# Добавляем задачи генерации бинарника в разных форматах - специфика сборки под Pico
pico_add_extra_outputs(01_blink)
```
- В итоге должна получиться структура файлов, как в схеме ниже, всего 4 файла. Именно этих четырех файлов достаточно для сборки проекта и получения бинарного файла прошивки:
```
mcu
|-- 01-blink
	|-- main.c
	|-- CMakeLists.txt
	|-- linker_rp2040.ld
    |-- pico_sdk_import.cmake
```
## 4. Собираем в папке build

Сборку принято производить в отдельной папке `build`. Это позволяет изолировать в ней все процессы сборки (при сборке генерируется огромное количество промежуточных файлов), а также легко очищать и пересобирать проект. И хранить в репозитории (подвергать контролю версий) только исходные файлы.

``` bash
# Мы должны находиться в папке нашего проекта 01-blink
# Создаем папку build
mkdir build
cd build

# Запускаем генерацию сценария сборки с помощью cmake
# Две точки - это путь к папке c CMakeLists.txt,
# т.к. она у нас на один уровень выше
# Флагом указываем генерировать сценарий для make
cmake -G "Unix Makefiles" ..

# Запускаем сценарий сборки.
# Здесь происходят препроцессинг, компиляция,
# линковка, генерация разных типов выходных файлов
make
```

В результате, в папке build должны появиться множество файлов, среди которых нам интересны `01_blink.bin` и `01_blink.uf2`, о чем будет речь дальше.

## 5. Загружаем прошивку в Pico

В результате сборки получается .bin файл, это и есть прошивка. Чтобы процессор микроконтроллера начал эту прошивку исполнять, ее надо прошить в память этого микроконтроллера. Это низкоуровневая и крайне специфичная процедура и почти всегда для нее нужен специальный прибор, называющийся программатор или отладчик. Однако, RP2040 уникален тем, что имеет простой механизм обновления. В RP2040 с завода имеется микропрограмма - stage 1 загрузчик, реализующий USB Mass Storage Class. Этот загрузчик есть в каждом RP2040 и его невозможно удалить или изменить. За счет этого загрузчика для обновления прошивки нужно:
	- запустить stage 1 загрузчик
		- отключаем питание от платы
		- зажимаем кнопку BOOTSEL
		- подаем питание на плату
		- отпускаем кнопку BOOTSEL
		- pico должна отобразиться как флешка в проводнике компьютера
	- загрузить прошивку
		- копируем .uf2 файл с компьютера на "флешку"
		- после этого "флешка" должна отключиться, а прошивка сразу начинает исполняться на плате