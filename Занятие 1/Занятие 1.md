
## 1. Проверяем установку необходимых программ

### Важные общие принципы
#### Path

Компьютерная программа - это набор инструкций и данных, запускаемый через исполняемый файл с расширением .exe на Windows и без расширения на Linux/MacOS. Установить программу - значит скачать исполняемый файл и набор дополнительных файлов вместе с ним, распаковать их, преобразовать и разместить их в нужном месте файловой системы компьютера. Все эти действия автоматически делает установщик программы, именно его вы обычно скачиваете и запускаете. Для офисного ПО, игр и прочих бытовых задач достаточно скачать и запустить установщик. Однако, для разработки необходимо обеспечить возможность одним программам находить другие, а так же запускать программы из терминала. Чтобы это было возможно, в настройках системы необходимо отметить существование свежеустановленной программы. Для этого используются так называемые переменные среды, а именно переменная PATH. **Для того, чтобы программа была доступна для запуска из терминала, необходимо в PATH добавить путь к ее исполняемому файлу**. На linux и macos это автоматически делает пакетный менеджер, на windows либо в установщике может быть такая галочка, которую нужно поставить, либо надо добавить переменную самостоятельно.
Типовая проблема на WIndows, что программа установлна, но в терминале она не доступна, заключается именно в том, что данная программа не добавлена в PATH.
#### Командная строка

Для выполнения большинства действий мы будем использовать командную строку (терминал, консоль).
- Linux
	Командна строка стандартная и запускается сочетанием клавишь **Ctrl+Alt+T** либо как приложение Terminal
- MacOS
	Можно использовать стандартный Tetminal.app или iTerm.app, лишенный некоторых недостатков стандартного терминала
- Windows
	В windows есть два приложения реализующие терминал - это cmd и powershell. Оба имеют неудобства, однако ==в данном курсе следует использовать powershell==, т.к. он имеет unix сокращения базовых операций, сохранение команд между запусками и поиск. Если терминал пишет, что некоторая команда не существует, проверьте, действительно ли вы работает в powershell.
#### Пакетный менеджер

Здесь краткая информация о том, как устанавливать программы на компьютер.
- Linux
	На линукс есть встроенный пакетный менеджер apt, все установки делаются через него, дополнительные действия не нужны
- MacOS
	На MacOS необходимо установить (если он до сих пор не установлен) пакетный менеджер homebrew и использовать его командой brew.
- Windows
	Хоть на windows и существуют пакетные менеджеры, они имеют ряд проблем, поэтому установки всех программ прозводятся путем скачивания и запуска официального установщика нужной программы 

### Переходим к делу

Открываем терминал и последовательно проверяем установку всех нужных программ. Если программа не установлена - устанавливаем. Если программа установлена, но не доступна через терминал - разбираемся с PATH.

- Система контроля версий git:
	- выполнить в терминале ```git --version```;
	- в ответ должна отобразиться версия, например ```git version 2.52.0```;
	- если версии нет, нужно [[Установить git]];

- Система автоматизации сборки программного обеспечения cmake:
	- выполнить в терминале ```cmake --version```;
	- в ответ должна отобразиться версия, например ```cmake version 4.2.1```;
	- если версии нет, нужно [[Установить cmake]];

- Система исполнения сценариев make:
	- выполнить в терминале ```make --version```;
	- в ответ должна отобразиться версия, например ```GNU Make 3.81```;
	- если версии нет, нужно [[Установить make]].

- Компилятор arm-none-eabi-gcc:
	- выполнить в терминале ```arm-none-eabi-gcc --version```;
	- в ответ должна отобразиться версия, например ```arm-none-eabi-gcc (Arm GNU Toolchain 15.2.Rel1 (Build arm-15.86)) 15.2.1 20251203```;
	- если версии нет, нужно [[Установить arm-none-eabi-gcc]];

- Утилита для работы с бинарниками RP2040 picotool:
	- выполнить в терминале ```picotool version```;
	- в ответ должна отобразиться версия, например ```picotool v2.2.0-a4```;
	- если версии нет, нужно [[Установить picotool]].

- Редактор кода VSCode:
	- выполнить в терминале ```code --version```;
	- в ответ должна отобразиться версия, например ``````;
	- если версии нет, нужно установить VSCode.
## 2. Клонируем SDK и организуем структуру папок

``` bash
# Для MacOS и Linux переходим в директорию пользователя
# Не обязательно работать именно в корне, рекомендуется организовать
# структуру папок, например ~/projects/
cd ~/

# Для Windows переходим на диск С: (либо любой другой), чтобы
# избежать кирилических символов в пути
# Не обязательно работать именно в корне, рекомендуется организовать
# структуру папок, например C:/projects/ 
cd C:/

# Далее, действия для всех ОС одинаковые:

# Создаем папку pico, в которой будет проиходить весь курс
mkdir pico
cd pico

# Папка для собственных проектов
mkdir ant-mcu

# Репозиторий с Pico SDK
git clone -b master https://github.com/raspberrypi/pico-sdk.git
cd pico-sdk
git submodule update --init
```

В результате вышеописанных действий на компьютере, в папке pico, должна появиться содержащая весь SDK папка pico-sdk. В ней мы ничего не меняем, это набор инструментов от производителя pico для создания прошивок под их микроконтроллеры. Также, должна появится пустая папка ant-mcu, в которой мы будем создавать наши собственные программы.

==Внимание! Обязательным шагом после клонирования pico-sdk является установка переменной среды PICO_SDK_PATH на путь к папке pico-sdk (в примере это C:/pico/pico-sdk/). [[Как добавить системную переменную]].==
## 3. Создаем первый проект

- Создаем папку с первой прошивкий, ее задача будет помигать светодиодом, поэтому называем ее ```01-blink```. Последняя команда откроет эту папку в VSCode

``` bash
cd ant-mcu
mkdir 01-blink
cd 01-blink
code .
```

- Копируем файл ```pico_sdk_import.cmake``` из pico/pico-sdk/external/pico_sdk_import.cmake
- Создаем файл с исходным кодом ```main.c```. Пишем в этот файл минимально рабочий пример кода, который мигает светодиодом

``` c
#include "pico/stdlib.h"
#include "hardware/gpio.h"

const uint LED_PIN = 25;

int main()
{
	gpio_init(LED_PIN);
	gpio_set_dir(LED_PIN, GPIO_OUT);

	while (1)
	{
		gpio_put(LED_PIN, 0);
		sleep_ms(250);
		gpio_put(LED_PIN, 1);
		sleep_ms(1000);
	}
}
```

- Создаем файл со скриптом сборки нашего проекта ```CMakeLists.txt```. Пишем в этот файл скрипт для сборки прошивки под RP2040

``` cmake

# Требуем минимальную версию cmake - типовая строчка для любого CMakeLists.txt
cmake_minimum_required(VERSION 3.15)

# Задаем параметр с используемой платой и микроконтроллером для Pico SDK - специфика сборки под Pico
set(PICO_BOARD pico)
set(PICO_PLATFORM rp2040)

# Добавляем файл, автоматически подтягивающий Pico SDK в наш проект - специфика сборки под Pico
include(pico_sdk_import.cmake)

# Создаем проект с именем 01_blink - типовая строчка для любого CMakeLists.txt
project(01_blink)

# Вызываем функцию инициализации Pico SDK - специфика сборки под Pico
pico_sdk_init()

# Добавляем в проект файлы с исходным кодом - типовая строчка для любого CMakeLists.txt
add_executable(01_blink
	main.c
)

# Указываем на какие библиотеки ссылается наш код - типовая строчка для любого CMakeLists.txt
target_link_libraries(01_blink
	pico_stdlib
)

# Добавляем задачи генерации бинарника в разных форматах - специфика сборки под Pico
pico_add_extra_outputs(01_blink)
```
- В итоге должна получиться следующая структура файлов, всего 3 файла. Именно этих трех файлов достаточно для сборки проекта и получения бинарного файла прошивки:
```
ant-mcu
|-- 01-blink
 	|-- main.c
 	|-- CMakeLists.txt
    |-- pico_sdk_import.cmake
```
## 4. Собираем в папке build

Сборку принято производить в отдельной папки ```build```. Это позволяет изолировать в ней все процессы сборки (при сборке генерируется огромное количество  промежуточных файлов), а также легко очищать и пересобирать проект.
```
``` bash
# Мы должны находиться в папке нашего проекта 01-blink
# Создаем папку build
mkdir build
cd build

# Запускаем генерацию сценария сборки с помощью cmake
# Две точки - это путь к папке c CMakeLists.txt,
# т.к. она у нас на один уровень выше
# Флагом указываем генерировать сценарий для make
cmake -G "Unix Makefiles" ..

# Запускаем сценарий сборки.
# Здесь происходят препроцессинг, компиляция,
# линковка, генерация разных типов выходных файлов
make
```

В результате, в папке build должны появиться множество файлов, среди которых нам интересны ```01_blink.bin``` и ```01_blink.uf2```, о чем будет речь дальше.

## 5. Загружаем прошивку в Pico

В результате сборки получается .bin файл, это и есть прошивка. Чтобы процессор микроконтроллера начал эту прошивку исполнять, ее надо прошить в память этого микроконтроллера. Это низкоуровневая и крайне специфичная процедура и почти всегда для нее нужен специальный прибор, называющийся программатор или отладчик. Однако, RP2040 уникален тем, что имеет простой механизм обновления. В RP2040 с завода имеется микропрограмма - stage 1 загрузчик, реализующий USB Mass Storage Class. Этот загрузчик есть в каждом RP2040 и его невозможно удалить или изменить. За счет этого загрузчика для обновления прошивки нужно:
	- запустить stage 1 загрузчик
		- отключаем питание от платы
		- зажимаем кнопку BOOTSEL
		- подаем питание на плату
		- отпускаем кнопку BOOTSEL
		- pico должна отобразиться как флешка в проводнике компьютера
	- загрузить прошивку
		- копируем .uf2 файл с компьютера на "флешку"
		- после этого "флешка" должна отключиться, а прошивка сразу начинает исполняться на плате