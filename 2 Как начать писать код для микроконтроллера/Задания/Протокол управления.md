---
тема: Управляемый светодиод
автор: Егор Анатольевич Денисов
дата: 2026-02-11
---

# Результат

- [ ] создана папка с файлами `protocol-task.h` и `protocol-task.c`;
- [ ] `protocol-task.c` добавлен в `CMakeLists.txt`
- [ ] в `protocol-task` созданы функции инициализации и обработчика;
- [ ] `protocol-task.c` написана логика протокола команд;
- [ ] в `main.c` добавлена инициализация и регулярный вызов обработчика `protocol-task`;
- [ ] в `main.c` в протокол добавлена команда `version` и колбэк для этой команды;
- [ ] прошивка скомпилирована и загружена на Pi pico
- [ ] на отправку команды `version` через COM-порт, после нажатия `Enter`, устройство выдает свои имя и версию

# Инструкция

1. создать в проекте папку `protocol-task`. В папке создайте файлы `protocol-task.h` и `protocol-task.c`. Должна получиться следующая структура файлов:

```
02-control
|-- stdio-task
|   |-- stdio-task.h
|   `-- stdio-task.c
|-- protocol-task
|   |-- protocol-task.h
|   `-- protocol-task.c
|-- main.c
|-- CMakeLists.txt
|-- memmap_rp2040.ld
|-- pico_sdk_import.cmake
```

2. в `CMakeLists.txt` добавить в add_executable включение исходных файлов `protocol_task`:

``` cmake
${CMAKE_CURRENT_SOURCE_DIR}/protocol-task/protocol-task.c
```

3. в файл `protocol-task.h` добавить директиву препроцессора для предотвращения многократного включения заголовочного файла
4. в файл `protocol-task.h` добавить объявление типа `command_callback_t`, являющего указателем на функцию:

``` c
typedef void(*command_callback_t)(const char* args);
```

5. в файл `protocol-task.h` добавить объявление типа структуры команды, состоящего из имени команды, колбэка команды, описания команды:

``` c
typedef struct
{
	const char* command_name;
	command_callback_t command_callback;
	const char* command_help;
} api_t;
```

6. в файл `protocol-task.h` добавить объявление прототипа функции инициализации, принимающей аргументом указатель на массив команд:

``` c
void protocol_task_init(api_t* device_api);
```

7. в файл `protocol-task.h` добавить объявление прототипа функции обработчика, принимающей аргументом строку с командой:

``` c
void protocol_task_handle(char* command_string);
```

---

8. в файл `protocol-task.c` добавить заголовочный файл `protocol-task.h`;
9. в файл `protocol-task.c` добавить заголовочный файл стандартной библиотеки ввода-вывода;
10. в файл `protocol-task.c` добавить заголовочный файл стандартной библиотеки работы со строками `string.h`;
11. в файл `protocol-task.c` добавить переменные для хранения указателя на массив команд и его размер:

``` c
static api_t* api = {0};
static int commands_count = 0;
```

12. в файл `protocol-task.c` добавить реализацию функции инициализации. Функция должна сохранить указатель на массив комманд в переменную `api`, подсчитать число команд и сохранить его в переменную `commands_count`;

> [!ATTENTION] Подсказка
> В массиве команд, после последней команды будет расположен элемент с нулевым значением вместо имени команды. По нему можно понять, что вы дошли до конца массива команд. 

13. в файл `protocol-task.c` создать обработчик. Добавить в обработчик проверку на то, что `command_string` не равно `NULL`. Если `command_string` равно `NULL`, то выйти из обработчика: строка команды еще не получена;

14. написать логику обработки полученной строки. Делим ее на команду и аргументы:

``` c
const char* command_name = command_string;
const char* command_args = NULL;

char* space_symbol = strchr(command_string, ' ');
if (space_symbol)
{
	*space_symbol = '\0';
	command_args = space_symbol + 1;
}
else
{
	command_args = "";
}
```

15. добавить вывод найденных имени команды и ее аргументов;

16. написать цикл, который проходит по массиву команд `api` и ищет совпадение имени команды;

> [!ATTENTION] Подсказка
> Для сравнения строк предлагается использовать функцию `strcmp()`. Она возвращает 0, если строки равны.
> Пример ее использования: `strcmp(command_name, api[i].command_name)`

17. вызывать колбэк найденой команды. В аргументы колбэка передать строку с аргументами от пользователя:
  
``` c
api[i].command_callback(command_args);
```

18. вывести ошибку, если команда не была найдена в списке команд;

---

20. в `main.c` добавить включение заголовочного файла модуля `protocol-task`:

``` c
#include "protocol-task/protocol-task.h"
```

21. в `main.c` создать функцию с именем `version_callback` для вывода версии устройства:

``` c
void version_callback(const char* args)
{
	printf("device name: '%s', firmware version: %s\n", DEVICE_NAME, DEVICE_VRSN);
}
```

22. в `main.c` создать массив команд с одной командой `version`, указателем на колбэк этой команды и с описанием:

``` c
api_t device_api[] =
{
	{"version", version_callback, "get device name and firmware version"},
	{NULL, NULL, NULL},
};
```

> [!ATTENTION] Внимание!
> Последним элементом массива должна быть нулевая структура. Это наша договоренность, чтобы легко определять длину массива.

22. добавить в `main.c` инициализацию `protocol-task`. Передать аргументом структуру `device_api`;
23. добавить в `main.c` вызов обработчика `protocol-task`. Передать аргументом строку, считанную `stdio_task_handle()`;
24. скомпилировать прошивку, загрузить в RP2040, проверить работоспособность. На отправленную команду `version` в COM-порт, RP2040 должен возвращать имя устройства и версию прошивки.