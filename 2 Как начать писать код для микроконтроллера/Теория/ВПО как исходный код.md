Мы обсудили, что у ВПО есть три формы: ВПО как код, ВПО как файл, ВПО как байты в памяти. В прошлый раз мы разобрались с последними двумя формами, и специально не углублялись в состав кода. Сейчас же разберемся какой набор кода нам нужен, чтобы ваша программа начала исполняться.

Давайте возьмём прошлый проект blink и пройдём последовательно от самых первых инструкций, исполняемых процессором, до самой главной строчки кода  — включение светодиода.


## Структура кода ВПО

Из каких файлов состоял ваш проект blink:

```
|-- 01-blink
	|-- main.c
	|-- CMakeLists.txt
	|-- memmap_rp2040.ld
	|-- pico_sdk_import.cmake
```
********
	- main.c — исходный код приложения
	- CMakeLists.txt — описание сборки
	- pico_sdk_import.cmake  — подключение PicoSDK (подключаются автоматически)
	- memmap_rp2040.ld — линкер-скрипт


##  Код приложения (main.c)

Это самый главный файл `main.c`. В нём заложен функционал программы (в данном случае мигание светодиодом). 

```c
// подключаем библиотеки из pico SDK
#include "pico/stdlib.h"
#include "hardware/gpio.h"


// задаем константу с номером ножки, к которой подключен светодиод
// номер можно узнать и проверить в документации к плате
const uint LED_PIN = 25;

int main()
{

	// Инициализация STDIO
	stdio_init_all();
	// Инициализация GPIO вывода
	gpio_init(LED_PIN);
	gpio_set_dir(LED_PIN, GPIO_OUT);

	// Бесконечный цикл, чтобы светодиод мига все время
	while (1)
	{
		gpio_put(LED_PIN, 0);
		sleep_ms(250);
		gpio_put(LED_PIN, 1);
		sleep_ms(1000);
	}
}

```

Функционал устройства очень важное понятие, ведь ради него и делается наше устройство. Остальной код это лишь способ этот функционал реализовать. Стоит отметить, что по мере увеличения и усложнения функционала наша кодовая база будет расти, мы можем не держать весь код в одном файле, а распределять его по разным файлам. 

### Подключение внешнего кода

В самом начале `main.c` мы при помощи директивы препроцессора `include` подключаем все необходимые нам заголовочные файлы. В них содержится описание функций, а сам код компилируется отдельно из `*.c` файлов.  Всё что делает эта директива -- вставляет содержимое указанного файла. И всё. Но это инструмент, который позволяет строить  сложные системы из маленьких простых частей. Внутри этих двух файлов в свою очередь есть свои `include`, а внутри них свои и так далее. Вот, например, дерево подключения `pico/stdlib.h`:

```
main.c (27 строк)
└── pico/stdlib.h
    └── pico.h
        └── pico/types.h
            └── pico/assert.h
                ├── stdbool.h (компилятор)
                └── assert.h (newlib)
                    └── _ansi.h
                        ├── newlib.h
                        └── sys/config.h
            └── stdint.h (компилятор)
                └── stdint.h (newlib)
                    └── machine/_default_types.h  ← Здесь определяются базовые типы!
                    └── sys/_stdint.h             ← Здесь typedef uint8_t, uint32_t
        └── pico/version.h
        └── pico/config.h
    └── hardware/gpio.h
        └── hardware/structs/sio.h   ← Структура для работы с GPIO
        └── hardware/structs/iobank0.h
    └── hardware/uart.h
    └── pico/time.h
```

Вставками кода занимается препроцессор. И после окончания его работы файл  содержит в себе **3622 строки**! И это только объявления типов, структур и inline-функций. 

>[!NOTE] Попробуйте
> Если вам интересно посмотреть на этот файл, можете сами получить его при сборке. Для этого лишь надо сказать компилятору, чтобы он не удалял результаты препроцессинга.
> 
> Для этого добавьте в `CMakeLists.txt` после требования к минимальной версии, строчку
> ```
> set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -save-temps=obj")
> ```
> И после выполнения сборки по пути `build\СMakeFiles\01_blink.dir\main.c.i` будет лежать файл после препроцессинга

Поэтому всегда, думайте, что вы подключаете в свой `main.c`

### Объявление типов и констант

Дальше в нашем main.c мы объявили константу LED_PIN. Остановимся на том, как вообще объявляются типы и константы в наших исходных файлах. 

Все, что написано в `*.c` файлах вне кода функций по умолчанию видно лишь функциям внутри этого файла (это ограничение можно обойти, но об этом в другой раз). Это важное свойство позволяет скрывать нам от других участков кода детали реализации. Это похоже на использование  модификатора доступа `private`, но только при программировании ВПО. Если же вы хотите, чтобы ваши типы и константы были видны другом участкам кода, как будто они `public`, то необходимо объявлять их внутри `*.h` файлов. Тогда при подключении директивой `include` они автоматически попадут в другие `*.c` файлы. У этого есть и обратная сторона, если названия таких констант или типов совпадут, то появится ошибка, которую придется искать.

>[!NOTE] Из практики
>В одном из проектов нашей лаборатории мы подключали библиотеку, которая имела константу названную OK = 1. А внутри своего кода мы использовали константу OK = 0. И были очень удивлены, когда наши библиотеки начали возвращать значения отличные от OK. Поиск ошибки занял два дня.

### Функция main()

Как вы уже поняли, функция main это далеко не самая большая часть нашей прошивки. Тем не менее она крайне важна. Это отправная точка функционала нашего устройства. Именно здесь мы решаем какие модули будем использовать.

> [!ATTENTION] Внимание!
> Компилятор оптимизирует код, чтобы не использовать лишние данные в памяти микропроцессора. Поэтому если Вы подключили  директивой ```include``` код, которые не будет использован, то компилятор его удалит
Для начала нам нужно проинициализировать все необходимые нам модули микроконтроллера. В нашем примере это: 

- `stdio_init_all()` — инициализация подсистемы ввода-вывода (для отладочного вывода)
- `gpio_init(LED_PIN)` — инициализация блока GPIO для конкретного пина
- `gpio_set_dir(LED_PIN, GPIO_OUT)` — настройка пина как выхода  

По мере усложнения проекта список инициализаций будет расти: настройка тактирования, таймеров, интерфейсов связи (UART, SPI, I2C), прерываний и других модулей. Здесь нужно иметь в виду, что некоторые аппаратные модули опираются на другие и важно соблюдать порядок. Первым обычно настраивается тактирование, так как оно требуется всем модулям. Если вы хотите использовать `printf` для вывода, то сначала нужно инициализировать подсистему вывода.

После того, как все необходимые нам аппаратные модули работают, мы можем перейти к приложению. Поскольку, если модуль дойдёт до конца функции main, то исполнение программы завершится, в ВПО существует концепция **суперцикла**

>[!NOTE] Определение
**Суперцикл** (*англ. super loop, main loop, infinite loop*) — архитектурный паттерн встроенного программного обеспечения, при котором основная логика приложения выполняется внутри бесконечного цикла, обеспечивающего непрерывную работу программы до отключения питания или перезагрузки системы.

Внутри суперцикла выполняются регулярные задачи опроса модулей, отслеживания их состояний и передачи информации. 

>[!NOTE] Вопрос
>Постойте, а как мы попадаем в **main**?


## До функции main()

Продолжаем расширять наше понимание кода. В прошлом разделе мы узнали, что main это примерно 0.1% нашего кода. Сейчас мы узнаем, что на самом деле это далеко не первые инструкции исполняемые кодом.

**Во-первых**, как мы помним, самым первым исполняется загрузчик, который хранится в [[ROM]] и вообще говоря при включении исполнение начинается с него. Его адрес 0x00000000. 

Его задача инициализировать минимальную периферию, проверить не нажата ли кнопка BOOTSEL. Если она нажата нужно инициализировать USB и настроить всё так, чтобы ваш файл `.uf2` с прошивкой попал во Flash. После этого загрузчик перезагрузит микроконтроллер. 

Если же BOOTSEL не нажата, то нужно по стандартному протоколу общения с Flash-памятью по SPI проверить, есть ли в ее начале прошивка. Так происходит из-за того, что у RP2040 внешняя энергонезависимая память (Flash). В микроконтроллерах со встроенной flash-памятью исполнение обычно начинается с нее. Кстати, размер этого загрузчика около 16Кб, и в нём несколько тысяч инструкций, а мы еще не дошли до `main()`

**Во-вторых**, начинается исполнение загрузчика второй стадии. Да, в прошивке два загрузчика. Этот загрузчик очень небольшой и расположен в первых 256 байтах ВПО. Он будет скопирован из Flash в [[SRAM]] загрузчиком первой стадии. После копирования первый загрузчик командует процессору продолжить исполнение инструкций из расположения кода загрузчика второй стадии. Загрузчик второй стадии уже всё знает о нашей прошивке и о том, на какой микросхеме памяти хранится наша прошивка, а значит может настроить подходящий режим работы с памятью, чтобы корректно работал [[XIP]] и процессор думал, что прошивка лежит рядом с ним в доступной ему области памяти. Загрузчик второго уровня весит максимум 256 байт и содержит в себе примерно 64 инструкции.

**В-третьих**, начинается выполнение ==стартап-кода==. Если наличие двух предыдущих частей кода на самом деле обусловлены устройством конкретного микроконтроллера, то стартап-код будет присутствовать в ВПО для любого микроконтроллера. Обычно в него входит загрузка ==таблицы векторов, Reset Handler== и начальная инициализация ядра, памяти и важной периферии (подробнее о них поговорим дальше). И, наконец, передача управления в `main()`. Наш стартап-код содержит примерно 110 инструкций.

Ниже схема загрузки RP2040

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ЦЕПОЧКА ЗАГРУЗКИ RP2040                              │
└─────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  1. ЗАГРУЗЧИК ПЕРВОЙ СТАДИИ (Boot ROM)                              │
    │     Адрес: 0x00000000 │ Размер: ~16 КБ │ ~несколько тысяч инструкций│
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Инициализация минимальной периферии                              │
    │  • Проверка кнопки BOOTSEL                                          │
    │    ├─ Нажата → USB режим, ждём .uf2 файл                            │
    │    └─ Не нажата → проверка Flash по SPI                             │
    │  • Копирование boot2 из Flash в SRAM                                │
    │  • Передача управления загрузчику второй стадии                     │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  2. ЗАГРУЗЧИК ВТОРОЙ СТАДИИ (Boot2)                                 │
    │     Адрес: 0x10000000 │ Размер: 256 байт │ ~64 инструкции           │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Выполняется из SRAM (скопирован загрузчиком первой стадии)       │
    │  • Знает параметры конкретной микросхемы Flash                      │
    │  • Настраивает режим XIP (eXecute In Place)                         │
    │  • Передача управления стартап-коду                                 │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  3. СТАРТАП-КОД                                                     │
    │     Адрес: 0x10000100 │ ~110 инструкций                             │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Таблица векторов (адреса обработчиков прерываний)                │
    │  • Reset Handler (точка входа после сброса)                         │
    │  • Инициализация ядра, памяти и периферии                           │
    │  • Копирование .data из Flash в RAM                                 │
    │  • Обнуление .bss                                                   │
    │  • Передача управления в main()                                     │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  4. ФУНКЦИЯ main()                                                  │
    │     Адрес: 0x100002D0                                               │
    ├─────────────────────────────────────────────────────────────────────┤
    │  • Инициализация модулей (stdio, GPIO, ...)                         │
    │  • Суперцикл — бесконечный цикл работы приложения                   │
    └─────────────────────────────────────────────────────────────────────┘
```

## Код в памяти

Вопросы памяти при разработке ВПО являются одними из самых важных. ***Во-первых**,* потому что её обычно мало. ***Во-вторых**,* память это основное средство обмена данными между процессором и периферией, поэтому постоянно необходимо думать куда положить данные от периферии, чтобы процессор мог быстро их взять и обработать. ***И в-третьих,*** для процессора весь мир — это память, а значит в любой момент при вашей ошибке он может начать писать данные вместо памяти в регистры периферийных модулей, которые также связаны с ним по системной шине памяти, и тогда работоспособность вашего устройства будет под вопросом. И хорошо если вы узнаете об этом в процессе отладки, а не когда ваше устройство улетит в космос.

Перейдём к пожалуй самой сложной части всего нашего кода,  **к линкер-скрипту**. Это инструкции для программы компоновщика. По сути, всё что он делает это определяет в каких частях памяти будет лежать код, переменные, стек (подробнее о нем ниже) и так далее. Линкер-скрипт написан на отдельном языке. Написание линкер-скрипта это мастерство. Написание сложных линкер-скриптов это искусство. Мы не сможем в рамках курса разобраться со всеми нюансами создания линкер-скрипта, но попытаемся кратко описать самые важные части.

В начале идёт описание **MEMORY**, в котором размечены все регионы памяти, с которыми будет работать наше ВПО. Там описаны их стартовые адреса, размеры и имена.

Ниже код для проект blink, но c добавлением несколько переменных для наглядности дальнейших примеров.

```c
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// Глобальная константа
const uint LED_PIN = 25;

// Глобальная переменная (инициализированная)
uint32_t blink_count = 0;

// Глобальная переменная (неинициализированная)
uint32_t last_time;

int main()
{
    // Локальная переменная
    uint32_t delay = 250;

    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    while (1)
    {
        gpio_put(LED_PIN, 0);
        sleep_ms(delay);
        gpio_put(LED_PIN, 1);
        sleep_ms(delay * 4);
        blink_count++;
    }
}
```

Далее в разделе **SECTIONS** описывают различные секции памяти. Обычно их названия начинаются с точки, после чего в фигурных скобках указываются различные параметры секции. В самом конце указывается в каком регионе памяти будет располагаться данная секция. 
- Cекция `.boot2` определяет расположение загрузчика второй стадии во **FLASH**. 
- Cекция `.text`, в ней хранится код main и код SDK, эта секция также располагается во **FLASH**. 
- Секция `.rodata`, в ней хранятся константы. Созданная нами переменная `LED_PIN` может хранится именно там, поскольку не будет изменятся в ходе программы, она размечена в **FLASH**.
- Секция `.data`, в ней описано, где будут храниться глобальные переменные. Обычно размечена в ==**SRAM**, поскольку значение глобальных может меняться в процессе работы.== Из плюсов, у этих переменных будет постоянный адрес во время всей работы программы.
- Секция ```.bss```, в ней хранятся неинициализированные глобальные переменные. ==Это нужно для того, чтобы перед стартом программы стартап-код записал туда нулевые значения.==
На самом деле, такие таких секций может быть больше и они могут быть сложнее, но общие принципы остаются.

>[!NOTE] Определение
>Где же окажутся переменные?

| Переменная    | Тип                            | Секция    | Область памяти |
| ------------- | ------------------------------ | --------- | -------------- |
| `LED_PIN`     | `const uint`                   | `.rodata` | Flash          |
| `blink_count` | `uint32_t = 0`                 | `.data`   | SRAM           |
| `last_time`   | `uint32_t` (без инициализации) | `.bss`    | SRAM           |
| `delay`       | локальная `uint32_t`           | —         | Стек (SRAM)    |

Еще одна важная часть этого скрипта — разметка кучи и стека.

>[!NOTE] Определение
> **Куча** (*англ. Heap*) — область памяти для динамического выделения во время выполнения программы. Управляется программистом через malloc()/free().

Куча нам нужна, чтобы хранить данные о существовании которых мы не можем знать в процессе компиляции программы. Например, если о длине массива мы узнаем только от пользователя (например, требуемый размер окна данных считанных из АЦП), то его необходимо будет создать в куче при помощи команды `malloc`. После того, как пользователь решит, что он больше не будет пользоваться этим массивом, то мы можем вызвать `free` и освободить и так не очень большой объем памяти. Вообще еще одной большой задачей для разработчика ВПО является определение того, какие массивы данных стоит определить на этапе компиляции и тогда они попадут в секцию `.data`, а какие можно будет создать уже в процессе выполнения программы и тогда они разместятся в куче. Кучу контролирует аллокатор памяти, который находит свободные места в куче и удаляет ненужные данные.

>[!NOTE] Определение
>**Стек** (*англ. Stack*) — область памяти для хранения локальных переменных, адресов возврата из функций и сохранённых регистров. Работает по принципу LIFO (Last In, First Out).


Стек нам нужен, чтобы программа вообще могла функционировать. Если без кучи можно работать и просто сохранить все переменные и массивы в секции данных, то без стека невозможен даже вызов функций. В нём хранятся локальные переменные, адреса возврата из функций, аргументы функций и сохраняются регистры процессора. Он настолько важен, что внутри ядра процессора есть отдельный регистр быстрой памяти, в котором хранится указатель на его верхушку. Начало стека и его границы определяются в линкер-скрипте. Стек растёт с максимального адреса до минимального. Как только вы создадите слишком много переменных или вызовите слишком много вложенных функций произойдёт самый большой страх разработчика ВПО —переполнение стека или **Stack Overflow**. В таком случае, вам придётся либо искать в каком месте происходит большое выделение памяти, либо где слишком большая вложенность функций. Так как в RP2040 два ядра, соответственно там два стека.

Ниже представлена схема секций.

```
┌─────────────────────────────────────────────────────────────┐
│                         FLASH                                │
│                    0x10000000 - 0x101FFFFF                   │
├─────────────────────────────────────────────────────────────┤
│ .boot2      │ 0x10000000 │ 256 байт  │ Загрузчик 2          │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ .text       │ 0x10000100 │ ~7 КБ     │ Код main(), SDK      │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ .rodata     │ 0x10001E28 │ ~300 байт │ LED_PIN = 25         │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ .data (LMA) │ 0x10001F74 │ ~384 байт │ Копия для blink_count│
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                          SRAM                                │
│                    0x20000000 - 0x20041FFF                   │
├─────────────────────────────────────────────────────────────┤
│ .data (VMA) │ 0x200000C0 │ ~384 байт │ blink_count = 0      │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ .bss        │ 0x20000240 │ ~1 КБ     │ last_time (= 0)      │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ Heap ↓      │ 0x20000640 │ растёт ↓  │ malloc(), etc.       │
├─────────────┼────────────┼───────────┼──────────────────────┤
│     ...     │            │           │                      │
├─────────────┼────────────┼───────────┼──────────────────────┤
│ Stack ↑     │ 0x20042000 │ растёт ↑  │ delay = 250          │
└─────────────────────────────────────────────────────────────┘
```