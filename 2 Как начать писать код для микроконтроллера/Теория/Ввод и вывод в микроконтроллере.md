В прошлых разделах мы разобрались с составом кода, цепочкой загрузки и организацией памяти. Теперь проследим путь от одной строчки `printf` в ВПО до появления сообщения в терминале на вашем компьютере.

## Микроконтроллер без экрана — куда выводить?

В отличие от Raspberry Pi с монитором, микроконтроллер не имеет дисплея. Для отладки и обмена данными необходим интерфейс связи с компьютером. Ввод и вывод строятся через последовательный интерфейс: UART или USB. Именно поэтому в задании [[Hello World!]] мы подключаемся к микроконтроллеру через терминал — он и есть наш «экран» для прошивки.

## printf как абстракция

`printf` — стандартная функция языка C из заголовка `stdio.h`. Она не знает, куда именно попадут байты: в файл, на экран или «наружу» устройства. В десктопной среде операционная система сама подставляет нужное назначение. Во встраиваемой системе программист должен явно указать, куда направить поток вывода. Иначе вывод не будет работать.

## От printf к железу: цепочка вызовов

`printf` форматирует строку и вызывает низкоуровневую функцию записи (`_write`). В стандартной библиотеке C (newlib) эта функция по умолчанию ничего не делает — она лишь заглушка. Pico SDK предоставляет свою реализацию `_write`, которая передаёт данные в выбранный backend: UART или USB.

Вот как выглядит путь байтов от вашего кода до терминала:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              ПУТЬ ОТ printf ДО ТЕРМИНАЛА                                   │
└─────────────────────────────────────────────────────────────────────────────┘

    printf("Hello\n")
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Форматирование строки (newlib)                                     │
    │  "Hello\n" → байты 0x48 0x65 0x6C 0x6C 0x6F 0x0A                   │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  _write() — реализация Pico SDK                                    │
    │  Передаёт байты в backend stdio (UART или USB)                      │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Драйвер периферии (USB CDC или UART)                               │
    │  Запись в регистры модуля (memory-mapped I/O)                       │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  USB‑кабель → компьютер → виртуальный COM‑порт                     │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Терминал (PuTTY, minicom) открывает порт → текст на экране         │
    └─────────────────────────────────────────────────────────────────────┘
```

## Роль stdio_init_all()

Функция `stdio_init_all()` инициализирует подсистему ввода-вывода. Она настраивает backend (UART или USB) как «устройство» для stdout и stderr. Без вызова этой функции перед первым `printf` вывод не будет работать — драйвер периферии не готов, и байты просто некуда передать.

Как вы помните из [[ВПО как исходный код]], порядок инициализации важен: сначала `stdio_init_all()`, потом уже можно вызывать `printf`.

## Два варианта на RP2040: UART и USB CDC

В Pico SDK можно выбрать, куда пойдёт поток stdio:

| Вариант | Описание | Настройка в CMakeLists.txt |
|---------|----------|----------------------------|
| **UART** | Классический последовательный порт (пины TX/RX, фиксированная скорость baudrate). Для связи с компьютером требует USB‑UART‑адаптер | `pico_enable_stdio_uart(1)` |
| **USB CDC** | Виртуальный COM‑порт «из коробки» на плате Pico. Микроконтроллер подключается к USB‑порту компьютера и сам предоставляет COM‑порт. Данные передаются пакетами, поэтому baudrate не задаётся | `pico_enable_stdio_usb(1)` |

В нашем курсе используется USB CDC. Плата Pico подключается тем же кабелем, что и для записи прошивки — дополнительный адаптер не нужен.

>[!NOTE] Из практики
>Если вы смотрите настройки в PuTTY и видите поле «Скорость» (baudrate) — при работе через USB CDC его можно не менять. USB передаёт данные пакетами по высокоскоростному протоколу, а не побайтово с фиксированной скоростью, как UART.

## Аппаратная часть пути

Программа записывает байты в регистры периферийного модуля. Это та же идея memory-mapped I/O, о которой мы говорили в контексте памяти: вы «пишете в память» по определённому адресу, а фактически настраиваете или управляете периферией. При USB CDC данные попадают в буферы передачи, USB‑контроллер RP2040 формирует пакеты и отправляет их по USB‑кабелю.

## Ввод — та же цепочка в обратную сторону

Ввод работает по той же схеме, но в обратном направлении: вы нажимаете клавишу в терминале → байт отправляется в COM‑порт → USB → RP2040 → `getchar()` или `scanf()` получает символ. Это основа задания [[Echo в COM‑порте]], где микроконтроллер возвращает обратно то, что вы ввели.

| **[[Память как инструмент\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Время внутри микроконтроллера\|Следующий раздел]]** |
| ---------------------------------------------- | ------------------------------------------------------- | ------------------------------------------ |
