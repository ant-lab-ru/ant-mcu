В прошлых разделах мы разобрались с кодом, памятью, вводом-выводом и временем. Наш blink мигает, мы можем выводить текст в терминал и замерять интервалы. Но выполняет ли он свою задачу так, как задумано? Какой бы классный и красивый код мы ни написали, важно лишь одно — справляется ли он с функционалом устройства. В этом разделе проследим путь от «просто кода» к полноценному устройству.

## Функционал устройства

Мы уже говорили, что функционал — это то, ради чего делается устройство. В blink это мигание светодиодом. В более сложной системе — опрос датчиков, управление исполнительными механизмами, обмен данными с компьютером. Остальной код — лишь способ этот функционал реализовать.

>[!NOTE] Определение
>**Функционал устройства** — набор возможностей, которые устройство предоставляет пользователю или системе. Определение функционала — один из первых этапов разработки встраиваемой системы.

Одна из главных задач устройства — возможность **обмениваться информацией** с теми, кто им пользуется. Без этого наша прошивка остаётся замкнутой: мы не знаем, что происходит внутри, не можем отдать команду, не можем получить результат. Как только появляется обмен, появляется пользователь.

## Пользователь системы

Пользователем может быть не только человек. Это любая сущность, которая взаимодействует с устройством:

- **Человек** — через терминал, кнопки, дисплей
- **Другая встраиваемая система** — датчик, исполнительный механизм, другой микроконтроллер
- **Приложение на ПК** — скрипт на Python, программа настройки, система сбора данных

Во всех случаях для обмена нужен интерфейс. Как только появляется пользователь, появляется интерфейс. А как только появляется интерфейс — нужен протокол и архитектура обработки событий.

## От интерфейса к протоколу

Интерфейс — это точка соприкосновения устройства с внешним миром. В микроконтроллере это GPIO, UART, SPI, I2C, USB. Мы подробно разбирали путь от `printf` до терминала в разделе [[Ввод и вывод в микроконтроллере]]. Но интерфейс лишь передаёт байты. Чтобы они имели смысл, нужны **правила обмена** — протокол.

Протокол задаёт: в каком формате передаются данные, в каком порядке, как различаются команды и ответы. Например, в терминале вы вводите символ — микроконтроллер получает байт. Если договориться, что «1» — включить светодиод, «0» — выключить, то мы уже задали простой протокол. В более сложных системах протокол описывают в документации: структура пакетов, коды команд, порядок байт.

## API как слой над протоколом

Программист работает не с сырыми байтами, а с функциями. Набор функций, которые скрывают детали протокола и железа, называют **API** (Application Programming Interface). В Pico SDK это `gpio_put`, `uart_putc`, `stdio_init_all` и сотни других. Вы вызываете `gpio_put(LED_PIN, 1)` — не зная, в какой регистр и какие биты пишутся. API инкапсулирует протокол общения с периферией.

Когда вы пишете свой протокол для обмена с пользователем (например, команды в терминале), вы по сути создаёте свой API: функции типа `send_command()`, `parse_response()`, которые скрывают детали передачи байт.

## Архитектура обработки событий

Мы научили контроллер мигать, но он «глухой» и «слепой», пока спит в `sleep_ms`. Пользователь нажимает клавишу в терминале — а микроконтроллер в это время ждёт 250 миллисекунд и не обращает на ввод внимания. Линейное выполнение команд в суперцикле не подходит, когда нужно одновременно реагировать на ввод, вести таймеры и управлять выходами.

Как только появляется пользователь и интерфейс, возникает потребность в **архитектуре обработки событий**: не ждать блокирующе, а опрашивать ввод, проверять таймеры и реагировать на происходящее. Это переход от «сделал — подождал — сделал» к «проверил — отреагировал — проверил снова». В следующем разделе [[Архитектура ВПО]] мы разберём, как строить такое поведение: задачи, диспетчеры, машины состояний.

## Путь от ВПО к устройству

Ниже схема, как код превращается в устройство:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ПУТЬ ОТ ВПО К УСТРОЙСТВУ                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │  КОД (main.c, суперцикл)                                            │
    │  Функционал: мигание, опрос, управление                             │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  ПОЛЬЗОВАТЕЛЬ                                                       │
    │  Человек / другая система / приложение на ПК                        │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  ИНТЕРФЕЙС                                                          │
    │  GPIO, UART, SPI, I2C, USB — точка соприкосновения с миром          │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  ПРОТОКОЛ + API                                                     │
    │  Правила обмена данными, функции для работы с ними                  │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  АРХИТЕКТУРА                                                        │
    │  Обработка событий, неблокирующая логика, реактивное поведение      │
    └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  УСТРОЙСТВО                                                         │
    │  ВПО, выполняющее свой функционал и обменивающееся с миром          │
    └─────────────────────────────────────────────────────────────────────┘
```

| **[[Время внутри микроконтроллера\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Архитектура ВПО\|Следующий раздел]]** |
| ------------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------- |
